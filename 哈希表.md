# 哈希表

## 1.map

### 1.1 思想

通过存储键值对建立映射关系

#### [219. 存在重复元素 II](https://leetcode.cn/problems/contains-duplicate-ii/description/)

```c
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        int n=nums.size();
        unordered_map<int,int>map;
        for(int i=0;i<n;i++){
            if(map.find(nums[i])==map.end()){//如果nums[i]不在map中，将{nums[i],i}插入map中
                map[nums[i]]=i;
            }else{//如果存在，当前位置与最开始的下标作差
               int pos=map[nums[i]];
                if(abs(i-pos)<=k){
                    return true;
                }else{//如果距离大于k 则更新最新的nums[i]
               map[nums[i]]=i;
                }
             
            }  
        }
       return false;
    }
};

```
#### [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/description/)
##### 思想/做法：使用map，将相同的异位词挂在同一组下面
```c
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>>ans;
        unordered_map<string,vector<string>>map;
        for(auto str:strs){
            string tmp=str;//将当前str排序后，作为map的k 以后相同的异位词就挂在排序后的异位词下面
            sort(tmp.begin(),tmp.end());
            map[tmp].push_back(str);
        }
        for(auto& [k,v]:map){
            ans.push_back(v);//按照相同的key输出挂载的异位词字符串
        }
        return ans;
    }
};
```

#### [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description)
##### 思想：map来存储字符和下标的映射关系，如果map中不存在该字符，就插入map中。若map中存在该字符并且在滑动窗口的范围内，将map中的（旧）重复元素移出滑动窗口，将最新位置的元素纳入。
```c
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char,int>map;
        int n=s.size();
        int left=0;
        int MaxLen=0;
        for(int right=0;right<n;right++){
            if(!map.count(s[right])){
                map[s[right]]=right;
            }else{//如果当前字符已经在map中
                if(map[s[right]]>=left){//map[s[right]]表示当前字符上次出现在map的位置 如果这个位置在窗口内 表示现在有两个相同的元素在窗口内，一个在map[s[right]]的位置上 一个在right的位置 
                   left= map[s[right]]+1;//将左边界拉到重复元素的下一位
                }
                map[s[right]]=right;
            }
            MaxLen=max(MaxLen,right-left+1);
        }
            return MaxLen;
    }
};
```

## 2.vector

### 1.1 思想

用数组来模拟哈希，对数据进行计数统计

#### [242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram)

1. 通过用数组cnt来存储每个字母出现的次数（表示s串的字母次数），遍历t串时，减去cnt中出现的次数，，若在遍历过程中，cnt某个次数为负，则表示s串中出现的次数少于t中出现的次数，表示为不相等。

```c
class Solution {
public:
    bool isAnagram(string s, string t) {
      int sLen=s.size(),tLen=t.size();
      if(sLen!=tLen)return false;
      vector<int>cnt(26,0);
      for(int i=0;i<sLen;i++){
        cnt[s[i]-'a']++;//统计s中每个字符出现的次数  'c'-'a'=2 cnt[2]=1;
      }
      for(int i=0;i<tLen;i++){
        cnt[t[i]-'a']--;
        if(cnt[t[i]-'a']<0){//为什么不是>=0呢，因为会存在某个字符未遍历完的情况。
            return false;
        }
      }
      return true;
    }
};

```

2. ***简单方法***:排序后，对比每一个字符是否相等，若不相等，表示不是字母异位词。

```c
class Solution {
public:
    bool isAnagram(string s, string t) {
      int sLen=s.size(),tLen=t.size();
      if(sLen!=tLen)return false;
      sort(s.begin(),s.end());
      sort(t.begin(),t.end());
      for(int i=0,j=0;i<sLen&&j<tLen;i++,j++){
        if(s[i]!=t[j]){
            return false;
        }

      }
      return true;
    }
};
```
## 3.set

### 3.1 思想

#### [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description)
##### 思想：set中不存在该元素，将该元素插入set，若存在就从头删除s串中并且在set中出现的元素，直到set中不存在重复元素，再将该元素插入set

```c
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_set<char>set;
        int n=s.size();
        int left=0;
        int MaxLen=0;
        for(int right=0;right<n;right++){
            if(!set.count(s[right])){//当前字符不在set中
                set.insert(s[right]);
            }else{
                while(set.count(s[right])&&!set.empty()){
                    set.erase(s[left]);//不停的删除窗口左边界的元素，直到将要插入的元素的重复元素移出
                    left++;//移动左边界
                }
                set.insert(s[right]);//再插入新位置的元素
            }
             MaxLen=max(MaxLen,right-left+1);
        }
            return MaxLen;
    }
};
```
#### [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/description/)

```c
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        int n = nums.size();
        unordered_set<int> set;
        for (int i = 0; i < n; i++) {//自动剔除掉重复元素
            set.insert(nums[i]);
        }
        int MaxLen = 0;
        int count = 0;
        for (int num : set) {//遍历set中的元素
            int cur_num;
            if (!set.count(num - 1)) {//如果如果当前元素的前一个不在set中，表示可以为当前元素为起点，向后找
                count = 1;//从该起点开始计算 
                cur_num = num;
                while (set.count(cur_num + 1)) {//如果后面元素存在，数量加1 继续往后找
                    cur_num++;
                    count++;
                }
                MaxLen = max(MaxLen, count);
            }
        }
        return MaxLen;
    }
};

```
##### 偷懒做法：排序后，如果当前元素-1 等于前一个元素，表示他们是连续的 累计长度
```c

class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        int n=nums.size();
        int MaxCount=1;
        if(n==0)return 0;
        sort(nums.begin(),nums.end());
        int count=1;
        for(int i=1;i<n;i++){
            if(nums[i]==nums[i-1])continue;
            if(nums[i]-1==nums[i-1]){
                count++;
                 MaxCount=max(MaxCount,count);
            }else{
              count=1;
            }
           
        }
        return MaxCount;
    }
};

```
