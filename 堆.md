# 堆

## priority_queue

1. priority_queue 默认是大顶堆，小顶堆需显式指定 vector<int> 和 greater<int>。
2. 核心操作是 push()、top()、pop().

### 哈夫曼树
#### [3531. 哈夫曼树](https://www.acwing.com/problem/content/description/3534/)
###### 输入格式
第一行包含整数 $N$，表示叶子结点数量。
第二行包含 $N$ 个整数，表示每个叶子结点的权值。

###### 输出格式
输出一个整数，表示生成哈夫曼树的带权路径长度。

###### 数据范围
$2 \le N \le 1000$,
叶子结点的权值范围 $[1, 100]$。

###### 输入样例
```
5
1 2 2 5 9
```

###### 输出样例
```
37
```

```c
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    priority_queue<int,vector<int>,greater<int>>q;
    for(int i=0;i<n;i++){
        int x;
        cin>>x;
        q.push(x);
    }
    int wpl=0;
    while(q.size()>1){
        int a=q.top();
        q.pop();
        int b=q.top();
        q.pop();
        int c=a+b;
        wpl+=c;
        q.push(c);
    }
    cout<<wpl;
    return 0;
}

```


### [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/description/)
```c
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int,int>map;
        for(int i=0;i<nums.size();i++){
            map[nums[i]]++;
        }
        priority_queue<pair<int,int>>q;
        for(auto[k,v]:map){
            q.push({v,k});
        }
        vector<int>res;
        while(k>0){
           auto [count,num]=q.top();
           q.pop();
            res.push_back(num);
            k--;
        }
        return res;
    }
};

```
