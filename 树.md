# 树
## 树的遍历

### 建树（已知前序+空叶子节点位置）
#### [3384. 二叉树遍历](https://www.acwing.com/problem/content/description/3387/)
输入样例：
abc##de#g##f###

输出样例：
c b e g d f a

```c
#include<bits/stdc++.h>
using namespace std;
struct TreeNode{
    char val;
    struct TreeNode* left;
    struct TreeNode* right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x):val(x),left(nullptr),right(nullptr){}
};

TreeNode* Rebuild(int &i,string str){
    char c=str[i];
    i++;
    if(c=='#')return nullptr;
   TreeNode* root= new TreeNode;
   root->val=c;
   root->left=Rebuild(i,str);
   root->right=Rebuild(i,str);
   return root;
}
void Inorder(TreeNode* root){
    if(!root)return;
    Inorder(root->left);
    cout << root->val <<" ";
    Inorder(root->right);
}
int main(){
    string str;
    while(cin >> str){
       int i=0;
        TreeNode* root=Rebuild(i,str);
        Inorder(root);
    }
    return 0;
}

```
### 建立二叉搜索树
#### [3540. 二叉搜索树](https://www.acwing.com/problem/content/description/3543/)

##### 题目要求
输入一系列整数，利用所给数据建立一个二叉搜索树，并输出其**前序、中序和后序遍历序列**（输入中的重复元素，在输出的遍历序列中无需体现）。

##### 输入格式
1.  第一行一个整数 `n`，表示输入整数数量。
2.  第二行包含 `n` 个整数，用空格分隔。

##### 输出格式
共三行，按以下顺序输出：
1.  第一行：前序遍历序列
2.  第二行：中序遍历序列
3.  第三行：后序遍历序列

##### 数据范围
- 1 ≤ n ≤ 100
- 输入元素取值范围 [1, 1000]

##### 输入样例
5
1 6 5 9 8


##### 输出样例
1 6 5 9 8

1 5 6 8 9

5 8 9 6 1

```c
#include<bits/stdc++.h>
using namespace std;

struct TreeNode{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x):val(x),left(nullptr),right(nullptr){}
};
TreeNode* insert(TreeNode* root,int x){
    if(!root)return new TreeNode(x);
  
    if(x<root->val){
        root->left=insert(root->left,x);
    }else if(root->val<x){
        root->right=insert(root->right,x);
    }
    return root;
}

void preOrder(TreeNode* root){
    if(!root)return;
    cout << root->val<<" ";
    preOrder(root->left);
    preOrder(root->right);
}
void InOrder(TreeNode* root){
    if(!root)return;
   
    InOrder(root->left);
    cout << root->val<<" ";
    InOrder(root->right);
}
void PostOrder(TreeNode* root){
    if(!root)return;
    
    PostOrder(root->left);
    PostOrder(root->right);
    cout << root->val<<" ";
}
int main(){
    int n;
    cin >> n;
    TreeNode* root=nullptr;
    while(n>0){
        int x;
        cin >> x;
    root=insert(root,x);
        n--;
    }
    preOrder(root);
    cout<<endl;
    InOrder(root);
    cout<<endl;
    PostOrder(root);
    return 0;
}

```

### 重构二叉树（根据前序和中序建立二叉树）
#### [3598. 二叉树遍历](https://www.acwing.com/file_system/file/content/whole/index/content/4186525/)

#### 输入格式
输入包含多组测试数据。

每组数据占两行，每行包含一个大写字母构成的字符串，第一行表示二叉树的前序遍历，第二行表示二叉树的中序遍历。

#### 输出格式
每组数据输出一行，一个字符串，表示二叉树的后序遍历。

#### 数据范围
输入字符串的长度均不超过 26。

#### 输入样例
```
ABC
BAC
FDXEAG
XDEFAG
```

#### 输出样例
```
BCA
XEDGAF
```
```c
#include<bits/stdc++.h>
using namespace std;
struct TreeNode{
    char val;
    struct TreeNode* left;
    struct TreeNode* right;
    TreeNode():val(0),left(nullptr),right(nullptr){}
    TreeNode(char x):val(x),left(nullptr),right(nullptr){}
};

 TreeNode* buildTree(vector<char>& preorder, vector<char>& inorder) {
        if(preorder.size()==0||inorder.size()==0)return nullptr;
        TreeNode* root=new TreeNode;
        root->val=preorder[0];
        int i;
        for(i=0;i<inorder.size();i++){
            if(inorder[i]==root->val)break;
        }
        vector<char>leftInorder(inorder.begin(),inorder.begin()+i);
        vector<char>leftPreorder(preorder.begin()+1,preorder.begin()+1+i);
        root->left=buildTree(leftPreorder,leftInorder);
        vector<char>rightInorder(inorder.begin()+i+1,inorder.end());
        vector<char>rightPreorder(preorder.begin()+1+i,preorder.end());
        root->right=buildTree(rightPreorder,rightInorder);
        return root;
    }
void PostOrder(TreeNode* root){
    if(!root)return;
    PostOrder(root->left);
    PostOrder(root->right);
    cout<<root->val;
}
int main(){
    string preStr, inStr;
    while(getline(cin,preStr)&&getline(cin,inStr)){
       vector<char> PreOrder(preStr.begin(),preStr.end());
        vector<char> InOrder(inStr.begin(),inStr.end());
       TreeNode* root= buildTree(PreOrder,InOrder);
       PostOrder(root);
       cout<<endl;
    }
    return 0;
}

```


### 层序遍历
####  [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal)

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        if(!root)return vector<vector<int>>();
        queue<TreeNode*>q;
        TreeNode*p;
        vector<vector<int>>ans;
        q.push(root);
        while(!empty(q)){
            vector<int>tmp;
            int cur_size=q.size();
            for(int i=0;i<cur_size;i++){//一层一层的加入队列   如果没有for 只会将本节点的左右孩子加入 纳入到tmp，再将tmp纳入ans 并没有达到一层的效果
                  p=q.front();//取出队首的元素
                 q.pop();//移出队首元素
                 tmp.push_back(p->val);  //将元素的值加入tmp中
            if(p->left){//左孩子加入队列
                q.push(p->left);   
            }
            if(p->right){//右孩子加入队列
                q.push(p->right);
            }
            }
            
            ans.push_back(tmp);//将本层tmp加入ans
        }
        return ans;
    }
};
```
