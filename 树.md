# 树
## 树的遍历

### 建树（已知前序+空叶子节点位置）
#### [3384. 二叉树遍历](https://www.acwing.com/problem/content/description/3387/)
输入样例：
abc##de#g##f###

输出样例：
c b e g d f a

```c
#include<bits/stdc++.h>
using namespace std;
struct TreeNode{
    char val;
    struct TreeNode* left;
    struct TreeNode* right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x):val(x),left(nullptr),right(nullptr){}
};

TreeNode* Rebuild(int &i,string str){
    char c=str[i];
    i++;
    if(c=='#')return nullptr;
   TreeNode* root= new TreeNode;
   root->val=c;
   root->left=Rebuild(i,str);
   root->right=Rebuild(i,str);
   return root;
}
void Inorder(TreeNode* root){
    if(!root)return;
    Inorder(root->left);
    cout << root->val <<" ";
    Inorder(root->right);
}
int main(){
    string str;
    while(cin >> str){
       int i=0;
        TreeNode* root=Rebuild(i,str);
        Inorder(root);
    }
    return 0;
}

```
### 建立二叉搜索树
#### [3540. 二叉搜索树](https://www.acwing.com/problem/content/description/3543/)

##### 题目要求
输入一系列整数，利用所给数据建立一个二叉搜索树，并输出其**前序、中序和后序遍历序列**（输入中的重复元素，在输出的遍历序列中无需体现）。

##### 输入格式
1.  第一行一个整数 `n`，表示输入整数数量。
2.  第二行包含 `n` 个整数，用空格分隔。

##### 输出格式
共三行，按以下顺序输出：
1.  第一行：前序遍历序列
2.  第二行：中序遍历序列
3.  第三行：后序遍历序列

##### 数据范围
- 1 ≤ n ≤ 100
- 输入元素取值范围 [1, 1000]

##### 输入样例
5
1 6 5 9 8


##### 输出样例
1 6 5 9 8

1 5 6 8 9

5 8 9 6 1

```c
#include<bits/stdc++.h>
using namespace std;

struct TreeNode{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x):val(x),left(nullptr),right(nullptr){}
};
TreeNode* insert(TreeNode* root,int x){
    if(!root)return new TreeNode(x);
  
    if(x<root->val){
        root->left=insert(root->left,x);
    }else{
        root->right=insert(root->right,x);
    }
    return root;
}

void preOrder(TreeNode* root){
    if(!root)return;
    cout << root->val<<" ";
    preOrder(root->left);
    preOrder(root->right);
}
void InOrder(TreeNode* root){
    if(!root)return;
   
    InOrder(root->left);
    cout << root->val<<" ";
    InOrder(root->right);
}
void PostOrder(TreeNode* root){
    if(!root)return;
    
    PostOrder(root->left);
    PostOrder(root->right);
    cout << root->val<<" ";
}
int main(){
    int n;
    cin >> n;
    TreeNode* root=nullptr;
    unordered_set<int>s;
    while(n>0){
        int x;
        cin >> x;
        if(!s.count(x)){
             root=insert(root,x);
             s.insert(x);
        }
       
        n--;
    }
    preOrder(root);
    cout<<endl;
    InOrder(root);
    cout<<endl;
    PostOrder(root);
    return 0;
}

```


### 层序遍历
####  [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal)

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        if(!root)return vector<vector<int>>();
        queue<TreeNode*>q;
        TreeNode*p;
        vector<vector<int>>ans;
        q.push(root);
        while(!empty(q)){
            vector<int>tmp;
            int cur_size=q.size();
            for(int i=0;i<cur_size;i++){//一层一层的加入队列   如果没有for 只会将本节点的左右孩子加入 纳入到tmp，再将tmp纳入ans 并没有达到一层的效果
                  p=q.front();//取出队首的元素
                 q.pop();//移出队首元素
                 tmp.push_back(p->val);  //将元素的值加入tmp中
            if(p->left){//左孩子加入队列
                q.push(p->left);   
            }
            if(p->right){//右孩子加入队列
                q.push(p->right);
            }
            }
            
            ans.push_back(tmp);//将本层tmp加入ans
        }
        return ans;
    }
};
```
