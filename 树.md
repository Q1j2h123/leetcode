# 树
## 树的遍历

### 建树（已知前序+空叶子节点位置）
#### [3384. 二叉树遍历](https://www.acwing.com/problem/content/description/3387/)
输入样例：
abc##de#g##f###

输出样例：
c b e g d f a

```c
#include<bits/stdc++.h>
using namespace std;
struct TreeNode{
    char val;
    struct TreeNode* left;
    struct TreeNode* right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x):val(x),left(nullptr),right(nullptr){}
};

TreeNode* Rebuild(int &i,string str){
    char c=str[i];
    i++;
    if(c=='#')return nullptr;
   TreeNode* root= new TreeNode;
   root->val=c;
   root->left=Rebuild(i,str);
   root->right=Rebuild(i,str);
   return root;
}
void Inorder(TreeNode* root){
    if(!root)return;
    Inorder(root->left);
    cout << root->val <<" ";
    Inorder(root->right);
}
int main(){
    string str;
    while(cin >> str){
       int i=0;
        TreeNode* root=Rebuild(i,str);
        Inorder(root);
    }
    return 0;
}

```
### 建树（已知层序+空叶子节点位置）
输入样例：

a##

12#3###

1#2#3##

ab#c##d##


输出样例：

a

3 2 1

1 2 3

c d b a

```c
#include<bits/stdc++.h>
using namespace std;

struct TreeNode{
	char val;
	TreeNode *left;
	TreeNode *right;
	TreeNode():val(0),left(nullptr),right(nullptr){}
	TreeNode(char x):val(x),left(nullptr),right(nullptr){}
};

TreeNode* rebuild(int &i,string str){
	char c=str[i];
	if(c=='#'){
			i++;
		return nullptr;
	
	}
	TreeNode* root=new TreeNode(c);
	queue<TreeNode*>q;
	q.push(root);
	i++;
	while(!q.empty()&&i<str.size()){
		TreeNode* parent=q.front();
		q.pop();
		//构建左孩子
		char leftVal=str[i];
		if(leftVal!='#'){
			parent->left=new TreeNode(leftVal);
			q.push(parent->left);
		}else{
			parent->left=nullptr;
		} 
		i++;
		
		if(i>=str.size())break;
		char rightVal=str[i];
		if(rightVal!='#'){
			parent->right=new TreeNode(rightVal);
			q.push(parent->right);
		}else{
			parent->right=nullptr;
		}
		i++;
	}
	return root;
}

void InOrder(TreeNode* root){
	if(!root)return ;
	InOrder(root->left);
	cout <<root->val<<" ";
	InOrder(root->right);
}

int main(){
	string str;
	while(cin >>str){
		int i=0;
	TreeNode* root=	rebuild(i,str);
	InOrder(root);
	cout <<endl;
	}
	return 0;
} 




```

### 建立二叉搜索树
#### [3540. 二叉搜索树](https://www.acwing.com/problem/content/description/3543/)

##### 题目要求
输入一系列整数，利用所给数据建立一个二叉搜索树，并输出其**前序、中序和后序遍历序列**（输入中的重复元素，在输出的遍历序列中无需体现）。

##### 输入格式
1.  第一行一个整数 `n`，表示输入整数数量。
2.  第二行包含 `n` 个整数，用空格分隔。

##### 输出格式
共三行，按以下顺序输出：
1.  第一行：前序遍历序列
2.  第二行：中序遍历序列
3.  第三行：后序遍历序列

##### 数据范围
- 1 ≤ n ≤ 100
- 输入元素取值范围 [1, 1000]

##### 输入样例
5
1 6 5 9 8


##### 输出样例
1 6 5 9 8

1 5 6 8 9

5 8 9 6 1

```c
#include<bits/stdc++.h>
using namespace std;

struct TreeNode{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x):val(x),left(nullptr),right(nullptr){}
};
TreeNode* insert(TreeNode* root,int x){
    if(!root)return new TreeNode(x);
  
    if(x<root->val){
        root->left=insert(root->left,x);
    }else if(root->val<x){
        root->right=insert(root->right,x);
    }
    return root;
}

void preOrder(TreeNode* root){
    if(!root)return;
    cout << root->val<<" ";
    preOrder(root->left);
    preOrder(root->right);
}
void InOrder(TreeNode* root){
    if(!root)return;
   
    InOrder(root->left);
    cout << root->val<<" ";
    InOrder(root->right);
}
void PostOrder(TreeNode* root){
    if(!root)return;
    
    PostOrder(root->left);
    PostOrder(root->right);
    cout << root->val<<" ";
}
int main(){
    int n;
    cin >> n;
    TreeNode* root=nullptr;
    while(n>0){
        int x;
        cin >> x;
    root=insert(root,x);
        n--;
    }
    preOrder(root);
    cout<<endl;
    InOrder(root);
    cout<<endl;
    PostOrder(root);
    return 0;
}

```
### 建立BST，并找出每个节点的父节点
#### [3595. 二叉排序树](https://www.acwing.com/problem/content/description/3598/)

##### 题目：二叉排序树插入与父节点查询

###### 问题描述
给你 \(N\) 个关键字值各不相同的节点，要求将这些节点按顺序插入一个初始为空的二叉排序树（左子树节点值 < 根节点值 < 右子树节点值）。
每次成功插入一个节点后，输出该节点的父节点的关键字值；如果该节点是根节点（没有父节点），则输出 `-1`。

###### 输入格式
1.  第一行包含整数 \(N\)，表示待插入的节点数。
2.  第二行包含 \(N\) 个互不相同的正整数，表示要顺序插入节点的关键字值。

###### 数据范围
- \(1 \le N \le 100\)
- 节点关键字取值范围 \([1, 10^8]\)

###### 输入样例
```
5
2 5 1 3 4
```

###### 输出样例
```
-1
2
2
5
3
```

```c
#include<bits/stdc++.h>
using namespace std;

struct TreeNode{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode():val(0),left(nullptr),right(nullptr){}
    TreeNode(int x):val(x),left(nullptr),right(nullptr){}
};
int insert(TreeNode* &cur,TreeNode* parent,int x){
    if(!cur){
        cur=new TreeNode(x);
        return parent?parent->val:-1;
    }
    if(cur->val>x){
        return insert(cur->left,cur,x);
    }else if(cur->val<x){
        return insert(cur->right,cur,x);
    }else{
        return cur->val;
    }
    
}
int main(){
    int n;
    cin>>n;
    TreeNode* root=nullptr;
    for(int i=0;i<n;i++){
        int x;
        cin>>x;
    int parentVal=insert(root,nullptr,x);
    cout<<parentVal<<endl;
    }
    return 0;
}

```



### 重构二叉树（根据前序和中序建立二叉树）
#### [3598. 二叉树遍历](https://www.acwing.com/file_system/file/content/whole/index/content/4186525/)

#### 输入格式
输入包含多组测试数据。

每组数据占两行，每行包含一个大写字母构成的字符串，第一行表示二叉树的前序遍历，第二行表示二叉树的中序遍历。

#### 输出格式
每组数据输出一行，一个字符串，表示二叉树的后序遍历。

#### 数据范围
输入字符串的长度均不超过 26。

#### 输入样例
```
ABC
BAC
FDXEAG
XDEFAG
```

#### 输出样例
```
BCA
XEDGAF
```
```c
#include<bits/stdc++.h>
using namespace std;
struct TreeNode{
    char val;
    struct TreeNode* left;
    struct TreeNode* right;
    TreeNode():val(0),left(nullptr),right(nullptr){}
    TreeNode(char x):val(x),left(nullptr),right(nullptr){}
};

 TreeNode* buildTree(vector<char>& preorder, vector<char>& inorder) {
        if(preorder.size()==0||inorder.size()==0)return nullptr;
        TreeNode* root=new TreeNode;
        root->val=preorder[0];
        int i;
        for(i=0;i<inorder.size();i++){
            if(inorder[i]==root->val)break;
        }
        vector<char>leftInorder(inorder.begin(),inorder.begin()+i);
        vector<char>leftPreorder(preorder.begin()+1,preorder.begin()+1+i);
        root->left=buildTree(leftPreorder,leftInorder);
        vector<char>rightInorder(inorder.begin()+i+1,inorder.end());
        vector<char>rightPreorder(preorder.begin()+1+i,preorder.end());
        root->right=buildTree(rightPreorder,rightInorder);
        return root;
    }
void PostOrder(TreeNode* root){
    if(!root)return;
    PostOrder(root->left);
    PostOrder(root->right);
    cout<<root->val;
}
int main(){
    string preStr, inStr;
    while(getline(cin,preStr)&&getline(cin,inStr)){
       vector<char> PreOrder(preStr.begin(),preStr.end());
        vector<char> InOrder(inStr.begin(),inStr.end());
       TreeNode* root= buildTree(PreOrder,InOrder);
       PostOrder(root);
       cout<<endl;
    }
    return 0;
}

```


### 层序遍历
####  [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal)

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        if(!root)return vector<vector<int>>();
        queue<TreeNode*>q;
        TreeNode*p;
        vector<vector<int>>ans;
        q.push(root);
        while(!empty(q)){
            vector<int>tmp;
            int cur_size=q.size();
            for(int i=0;i<cur_size;i++){//一层一层的加入队列   如果没有for 只会将本节点的左右孩子加入 纳入到tmp，再将tmp纳入ans 并没有达到一层的效果
                  p=q.front();//取出队首的元素
                 q.pop();//移出队首元素
                 tmp.push_back(p->val);  //将元素的值加入tmp中
            if(p->left){//左孩子加入队列
                q.push(p->left);   
            }
            if(p->right){//右孩子加入队列
                q.push(p->right);
            }
            }
            
            ans.push_back(tmp);//将本层tmp加入ans
        }
        return ans;
    }
};
```
