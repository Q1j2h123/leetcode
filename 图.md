# 图
## 图的遍历
### BFS
#### [1971. 寻找图中是否存在路径](https://leetcode.cn/problems/find-if-path-exists-in-graph)
```c
class Solution {
public:
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {
        vector<vector<int>>adj(n);
        vector<bool>visited(n,false);
        queue<int>qu;
        for(auto& edge:edges){
            int x=edge[0];
            int y=edge[1];
            adj[x].push_back(y);//因为双向边 存0-1
            adj[y].push_back(x);//存 1-0
        }
        return  bfs(source,destination,adj,visited,qu);//只进行了一个bfs，是因为以source为起点，找不到destination时，表示他们不连通，则肯定不存在路径
    }
  bool  bfs(int source,int destination,vector<vector<int>>&adj,vector<bool>&visited,queue<int>&qu){
                if(source==destination)return true;  //判断边界情况 若只有一个顶点 即源点和终点一样
                visited[source]=true;//访问source
                qu.push(source);//将source入队
                while(!empty(qu)){
                    auto cur=qu.front();//取出队首元素
                    qu.pop();//移出
                    for(int neighbor:adj[cur]){//取出当前队首元素的所有邻居
                        
                        if(!visited[neighbor]){//如果该邻居没有被访问，则访问它 ，并将其入队 如果该邻居与des相等，则return true
                            visited[neighbor]=true;
                          if(neighbor==destination)return true;
                          qu.push(neighbor);  
                        }
                       
                    }
                }
                return false;//已经将source的邻居，以及邻居的邻居入队了，也并且都已访问。若终点不在被访问的队伍中，则表示从source出发 到达不了终点 表示source与destination不连通
        }
};
```
#### [200.岛屿数量](https://leetcode.cn/problems/number-of-islands)
##### 思路：通过bfs遍历该图,遇到陆地时，陆地数量加1 是因为 *** {bfs会去找附近连着的陆地（成片的陆地），直到将附近的陆地找完（grid[i][j]=0，将陆地淹没）} ***，再去找下一大块的陆地（进行下一轮for遍历找==1的点）
```c
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int row= grid.size();
        int col=grid[0].size();
        int count=0;
        for(int i=0;i<row;i++){
            for(int j=0;j<col;j++){
                if(grid[i][j]=='1'){
                    count++;
                    bfs(grid,i,j);//可能会进行多轮bfs 因为会存在多个成片的陆地
                }
            }
        }
        return count;
    }
   void bfs(vector<vector<char>>& grid,int i,int j){//bfs职责：找完从起始点出发周围附近全是1的点，并将这些点设为0 （淹没陆地） 本轮bfs任务结束
         int row= grid.size();
        int col=grid[0].size();
        queue<pair<int,int>>q;
        q.push({i,j});
        grid[i][j]='0';
        while(!empty(q)){
            auto cur=q.front();
            q.pop();
            int cur_r=cur.first;
            int cur_c=cur.second;
            if(cur_r+1<row&&grid[cur_r+1][cur_c]=='1'){//下
                    q.push({cur_r+1,cur_c});
                    grid[cur_r+1][cur_c]='0';
            }
            if(cur_r-1>=0&&grid[cur_r-1][cur_c]=='1'){//上
                    q.push({cur_r-1,cur_c});
                    grid[cur_r-1][cur_c]='0';
            }
            if(cur_c-1>=0&&grid[cur_r][cur_c-1]=='1'){//左
                    q.push({cur_r,cur_c-1});
                    grid[cur_r][cur_c-1]='0';
            }
            if(cur_c+1<col&&grid[cur_r][cur_c+1]=='1'){//下
                    q.push({cur_r,cur_c+1});
                    grid[cur_r][cur_c+1]='0';
            }

        }
    }
};
```

#### [994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/description/)

##### 思想：多源BFS，指会存在多个初始起点，同时向外蔓延，所以要找出初始状态下所有腐烂的橘子，将其加入队列中。按层扩散，直到全腐烂，若之后，还存在好的橘子，表示无法蔓延到这里来，返回-1 。如果从一开始就没有好的橘子，返回0

```c
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int row=grid.size();
        int col=grid[0].size();
        queue<pair<int,int>>q;//存储初始状态下的腐烂橘子
        int minute=0;
        int fresh=0;
        for(int i=0;i<row;i++){
            for(int j=0;j<col;j++){
                if(grid[i][j]==2){
                    q.push({i,j});//存储初始状态下的腐烂橘子
                }else if(grid[i][j]==1){
                    fresh++;
                }
            }
        }
        if(fresh==0)return 0;
        while(!empty(q)){
        
          int cur_size=q.size();
         bool has_rot=false;
         for(int i=0;i<cur_size;i++){//让所有腐烂橘子同步扩散，每轮扩散耗时 1 分钟
            bool tmp_has_rot=false;
            auto cur_rot=q.front();
            q.pop();
            int cur_rot_r=cur_rot.first;
            int cur_rot_c=cur_rot.second;
                if(cur_rot_r+1<row&&grid[cur_rot_r+1][cur_rot_c]==1){//下
                            grid[cur_rot_r+1][cur_rot_c]=2;
                            q.push({cur_rot_r+1,cur_rot_c});
                            tmp_has_rot=true;
                }
                if(cur_rot_r-1>=0&&grid[cur_rot_r-1][cur_rot_c]==1){//上
                            grid[cur_rot_r-1][cur_rot_c]=2;
                            q.push({cur_rot_r-1,cur_rot_c});
                            tmp_has_rot=true;
                }
                if(cur_rot_c+1<col&&grid[cur_rot_r][cur_rot_c+1]==1){//右
                            grid[cur_rot_r][cur_rot_c+1]=2;
                            q.push({cur_rot_r,cur_rot_c+1});
                            tmp_has_rot=true;
                }
                if(cur_rot_c-1>=0&&grid[cur_rot_r][cur_rot_c-1]==1){//左
                            grid[cur_rot_r][cur_rot_c-1]=2;
                            q.push({cur_rot_r,cur_rot_c-1});
                            tmp_has_rot=true;
                }
                if(tmp_has_rot)has_rot=true;
            }
            if(has_rot)minute++;
        }
       for(int i=0;i<row;i++){
            for(int j=0;j<col;j++){
                if(grid[i][j]==1)return -1;
            }
       }
        return minute;
    }
};
```
## 拓扑排序
### BFS 
#### 思想：找出所有入度为0的顶点（入队），从该顶点出发，消除与之相连的边，如果存在入度为0 就纳入队列中 直到将所有顶点都入队 则表示存在拓扑排序
#### [207. 课程表](https://leetcode.cn/problems/course-schedule/description/)

```c
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        vector<vector<int>>adj(numCourses);//adj中保存邻居
        vector<int>indegree(numCourses,0);
        for(auto& prerequisite:prerequisites){
            int x=prerequisite[0];
            int y=prerequisite[1];
            adj[y].push_back(x);
            indegree[x]++;//表示x存在一条入边
        }
        queue<int>q;
        int count=0;
        for(int i=0;i<numCourses;i++){
            if(indegree[i]==0){//将入度为0的点入队
                q.push(i);
                count++;
            }
        }
        while(!empty(q)){
            int cur=q.front();
            q.pop();
            for(int neighbor:adj[cur]){//遍历其邻居 消除相连的边 若还存在入度为0 则加入队列中
                indegree[neighbor]--;
                if(indegree[neighbor]==0){
                    q.push(neighbor);
                    count++;
                }
            }
        }
        return numCourses==count;//若加入队列中的点的数量与课程数相等，表示所有课程都可完成

    }
};
```
