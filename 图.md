# 图
## 图的遍历
### BFS
#### [1971. 寻找图中是否存在路径](https://leetcode.cn/problems/find-if-path-exists-in-graph)
```c
class Solution {
public:
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {
        vector<vector<int>>adj(n);
        vector<bool>visited(n,false);
        queue<int>qu;
        for(auto& edge:edges){
            int x=edge[0];
            int y=edge[1];
            adj[x].push_back(y);//因为双向边 存0-1
            adj[y].push_back(x);//存 1-0
        }
        return  bfs(source,destination,adj,visited,qu);
    }
  bool  bfs(int source,int destination,vector<vector<int>>&adj,vector<bool>&visited,queue<int>&qu){
                if(source==destination)return true;  //判断边界情况 若只有一个顶点 即源点和终点一样
                visited[source]=true;//访问source
                qu.push(source);//将source入队
                while(!empty(qu)){
                    auto cur=qu.front();//取出队首元素
                    qu.pop();//移出
                    for(int neighbor:adj[cur]){//取出当前队首元素的所有邻居
                        
                        if(!visited[neighbor]){//如果该邻居没有被访问，则访问它 ，并将其入队 如果该邻居与des相等，则return true
                            visited[neighbor]=true;
                          if(neighbor==destination)return true;
                          qu.push(neighbor);  
                        }
                       
                    }
                }
                return false;//已经将source的邻居，以及邻居的邻居入队了，也并且都已访问。若终点不在被访问的队伍中，则表示从source出发 到达不了终点 表示source与destination不连通
        }
};
```
#### [200.岛屿数量](https://leetcode.cn/problems/number-of-islands)
##### 思路：通过bfs遍历该图,遇到陆地时，陆地数量加1 是因为 *** {bfs会去找附近连着的陆地（成片的陆地），直到将附近的陆地找完（grid[i][j]=0，将陆地淹没）} ***，再去找下一大块的陆地（进行下一轮for遍历找==1的点）
```c
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int row= grid.size();
        int col=grid[0].size();
        int count=0;
        for(int i=0;i<row;i++){
            for(int j=0;j<col;j++){
                if(grid[i][j]=='1'){
                    count++;
                    bfs(grid,i,j);
                }
            }
        }
        return count;
    }
   void bfs(vector<vector<char>>& grid,int i,int j){//bfs职责：找完从起始点出发周围附近全是1的点，并将这些点设为0 （淹没陆地） 本轮bfs任务结束
         int row= grid.size();
        int col=grid[0].size();
        queue<pair<int,int>>q;
        q.push({i,j});
        grid[i][j]='0';
        while(!empty(q)){
            auto cur=q.front();
            q.pop();
            int cur_r=cur.first;
            int cur_c=cur.second;
            if(cur_r+1<row&&grid[cur_r+1][cur_c]=='1'){//下
                    q.push({cur_r+1,cur_c});
                    grid[cur_r+1][cur_c]='0';
            }
            if(cur_r-1>=0&&grid[cur_r-1][cur_c]=='1'){//上
                    q.push({cur_r-1,cur_c});
                    grid[cur_r-1][cur_c]='0';
            }
            if(cur_c-1>=0&&grid[cur_r][cur_c-1]=='1'){//左
                    q.push({cur_r,cur_c-1});
                    grid[cur_r][cur_c-1]='0';
            }
            if(cur_c+1<col&&grid[cur_r][cur_c+1]=='1'){//下
                    q.push({cur_r,cur_c+1});
                    grid[cur_r][cur_c+1]='0';
            }

        }
    }
};
```
