# 图
## 图的遍历
### BFS
#### [1971. 寻找图中是否存在路径](https://leetcode.cn/problems/find-if-path-exists-in-graph)
```c
class Solution {
public:
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {
        vector<vector<int>>adj(n);
        vector<bool>visited(n,false);
        queue<int>qu;
        for(auto& edge:edges){
            int x=edge[0];
            int y=edge[1];
            adj[x].push_back(y);//因为双向边 存0-1
            adj[y].push_back(x);//存 1-0
        }
        return  bfs(source,destination,adj,visited,qu);//只进行了一个bfs，是因为以source为起点，找不到destination时，表示他们不连通，则肯定不存在路径
    }
  bool  bfs(int source,int destination,vector<vector<int>>&adj,vector<bool>&visited,queue<int>&qu){
                if(source==destination)return true;  //判断边界情况 若只有一个顶点 即源点和终点一样
                visited[source]=true;//访问source
                qu.push(source);//将source入队
                while(!empty(qu)){
                    auto cur=qu.front();//取出队首元素
                    qu.pop();//移出
                    for(int neighbor:adj[cur]){//取出当前队首元素的所有邻居
                        
                        if(!visited[neighbor]){//如果该邻居没有被访问，则访问它 ，并将其入队 如果该邻居与des相等，则return true
                            visited[neighbor]=true;
                          if(neighbor==destination)return true;
                          qu.push(neighbor);  
                        }
                       
                    }
                }
                return false;//已经将source的邻居，以及邻居的邻居入队了，也并且都已访问。若终点不在被访问的队伍中，则表示从source出发 到达不了终点 表示source与destination不连通
        }
};
```
#### [200.岛屿数量](https://leetcode.cn/problems/number-of-islands)
##### 思路：通过bfs遍历该图,遇到陆地时，陆地数量加1 是因为 *** {bfs会去找附近连着的陆地（成片的陆地），直到将附近的陆地找完（grid[i][j]=0，将陆地淹没）} ***，再去找下一大块的陆地（进行下一轮for遍历找==1的点）
```c
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int row= grid.size();
        int col=grid[0].size();
        int count=0;
        for(int i=0;i<row;i++){
            for(int j=0;j<col;j++){
                if(grid[i][j]=='1'){
                    count++;
                    bfs(grid,i,j);//可能会进行多轮bfs 因为会存在多个成片的陆地
                }
            }
        }
        return count;
    }
   void bfs(vector<vector<char>>& grid,int i,int j){//bfs职责：找完从起始点出发周围附近全是1的点，并将这些点设为0 （淹没陆地） 本轮bfs任务结束
         int row= grid.size();
        int col=grid[0].size();
        queue<pair<int,int>>q;
        q.push({i,j});
        grid[i][j]='0';
        while(!empty(q)){
            auto cur=q.front();
            q.pop();
            int cur_r=cur.first;
            int cur_c=cur.second;
            if(cur_r+1<row&&grid[cur_r+1][cur_c]=='1'){//下
                    q.push({cur_r+1,cur_c});
                    grid[cur_r+1][cur_c]='0';
            }
            if(cur_r-1>=0&&grid[cur_r-1][cur_c]=='1'){//上
                    q.push({cur_r-1,cur_c});
                    grid[cur_r-1][cur_c]='0';
            }
            if(cur_c-1>=0&&grid[cur_r][cur_c-1]=='1'){//左
                    q.push({cur_r,cur_c-1});
                    grid[cur_r][cur_c-1]='0';
            }
            if(cur_c+1<col&&grid[cur_r][cur_c+1]=='1'){//下
                    q.push({cur_r,cur_c+1});
                    grid[cur_r][cur_c+1]='0';
            }

        }
    }
};
```

#### [994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/description/)

##### 思想：多源BFS，指会存在多个初始起点，同时向外蔓延，所以要找出初始状态下所有腐烂的橘子，将其加入队列中。按层扩散，直到全腐烂，若之后，还存在好的橘子，表示无法蔓延到这里来，返回-1 。如果从一开始就没有好的橘子，返回0

```c
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int row=grid.size();
        int col=grid[0].size();
        queue<pair<int,int>>q;//存储初始状态下的腐烂橘子
        int minute=0;
        int fresh=0;
        for(int i=0;i<row;i++){
            for(int j=0;j<col;j++){
                if(grid[i][j]==2){
                    q.push({i,j});//存储初始状态下的腐烂橘子
                }else if(grid[i][j]==1){
                    fresh++;
                }
            }
        }
        if(fresh==0)return 0;
        while(!empty(q)){
        
          int cur_size=q.size();
         bool has_rot=false;
         for(int i=0;i<cur_size;i++){//让所有腐烂橘子同步扩散，每轮扩散耗时 1 分钟
            bool tmp_has_rot=false;
            auto cur_rot=q.front();
            q.pop();
            int cur_rot_r=cur_rot.first;
            int cur_rot_c=cur_rot.second;
                if(cur_rot_r+1<row&&grid[cur_rot_r+1][cur_rot_c]==1){//下
                            grid[cur_rot_r+1][cur_rot_c]=2;
                            q.push({cur_rot_r+1,cur_rot_c});
                            tmp_has_rot=true;
                }
                if(cur_rot_r-1>=0&&grid[cur_rot_r-1][cur_rot_c]==1){//上
                            grid[cur_rot_r-1][cur_rot_c]=2;
                            q.push({cur_rot_r-1,cur_rot_c});
                            tmp_has_rot=true;
                }
                if(cur_rot_c+1<col&&grid[cur_rot_r][cur_rot_c+1]==1){//右
                            grid[cur_rot_r][cur_rot_c+1]=2;
                            q.push({cur_rot_r,cur_rot_c+1});
                            tmp_has_rot=true;
                }
                if(cur_rot_c-1>=0&&grid[cur_rot_r][cur_rot_c-1]==1){//左
                            grid[cur_rot_r][cur_rot_c-1]=2;
                            q.push({cur_rot_r,cur_rot_c-1});
                            tmp_has_rot=true;
                }
                if(tmp_has_rot)has_rot=true;
            }
            if(has_rot)minute++;
        }
       for(int i=0;i<row;i++){
            for(int j=0;j<col;j++){
                if(grid[i][j]==1)return -1;
            }
       }
        return minute;
    }
};
```
#### [130. 被围绕的区域](https://leetcode.cn/problems/surrounded-regions/description/)

##### 思想/做法：如果图中某些O被X围绕了 需要将这些O改为X 如果某些O是四个边缘的O 表示他们没有被围绕，因此从这些没有被围绕的O出发 找出相连的O，他们也是没有被围绕的。所以从四个边缘出发，先找出O，做好标记（防止把重复位置的O多次加入队列），将其入队 从队列中继续找相连的O，并且也做标记。到最后，如果存在还没有被标记的，则是需要改为X的O。

```c
class Solution {
public:
    void solve(vector<vector<char>>& board) {
        int row = board.size();
        int col = board[0].size();
        queue<pair<int, int>> q;
        for (int j = 0; j < col; j++) {
            if (board[0][j] == 'O') {
                q.push({0, j});
                board[0][j]='A';//标记为A 表示是安全的 不用将O改为X
            }
            if (board[row - 1][j] == 'O') {
                q.push({row - 1, j});
                board[row-1][j]='A';
            }
        }
        for (int i = 1; i < row - 1; i++) {
            if (board[i][0] == 'O') {
                q.push({i, 0});
                board[i][0]='A';
            }
            if (board[i][col - 1] == 'O') {
                q.push({i, col - 1});
                board[i][col-1]='A';
            }
        }
        while(!empty(q)){
           auto cur= q.front();
           int cur_x=cur.first;
           int cur_y=cur.second;
           q.pop();
           //向四周遍历，因为咱们是从边缘出发的，遇到O说明也是安全的 标记为A 
           if(cur_x+1<row&&board[cur_x+1][cur_y]=='O'){//下
            q.push({cur_x+1,cur_y});
            board[cur_x+1][cur_y]='A';
           }
           if(cur_x-1>=0&&board[cur_x-1][cur_y]=='O'){//上
            q.push({cur_x-1,cur_y});
            board[cur_x-1][cur_y]='A';
           }
           if(cur_y-1>=0&&board[cur_x][cur_y-1]=='O'){//左
            q.push({cur_x,cur_y-1});
            board[cur_x][cur_y-1]='A';
           }
           if(cur_y+1<col&&board[cur_x][cur_y+1]=='O'){//右
            q.push({cur_x,cur_y+1});
            board[cur_x][cur_y+1]='A';
           }
        }
        for(int i=0;i<row;i++){
            for(int j=0;j<col;j++){
                if(board[i][j]=='X'){
                    continue;
                }else if(board[i][j]=='O'){//剩余没有标记为O的 则需要改为X
                    board[i][j]='X';
                
                }else if(board[i][j]=='A'){
                    board[i][j]='O';
                }
            }
        }
    }
};

```
### DFS
#### [130. 被围绕的区域](https://leetcode.cn/problems/surrounded-regions/description/)
##### 思想：从四个边缘开始递归 ，如果四个边缘存在O 将他做标记（表示安全），依次再从该点出发向外找，做标记，若走到非O的地方，退出该层递归 从下一个边缘位置出发递归

```c
class Solution {
public:
    void solve(vector<vector<char>>& board) {
        int row=board.size();
        int col=board[0].size();
        for(int j=0;j<col;j++){
            dfs(board,0,j);//第一行
            dfs(board,row-1,j);//最后一行
        }
        for(int i=0;i<row;i++){
            dfs(board,i,0);//第一列
            dfs(board,i,col-1);//最后一列
        }
           for(int i=0;i<row;i++){
            for(int j=0;j<col;j++){
                if(board[i][j]=='X'){
                    continue;
                }else if(board[i][j]=='O'){
                    board[i][j]='X';
                
                }else if(board[i][j]=='A'){
                    board[i][j]='O';
                }
            }
        }
    }
    void dfs(vector<vector<char>>& board,int i,int j){
        int row=board.size();
        int col=board[0].size();
        if(i>=row||i<0||j>=col||j<0||board[i][j]!='O')return ;
            if(board[i][j]=='O'){
                board[i][j]='A';
                
            dfs(board,i+1,j);//下
            dfs(board,i-1,j);//上
            dfs(board,i,j-1);//左
            dfs(board,i,j+1);//右
            }
            
    }
};
```
#### [1971. 寻找图中是否存在路径](https://leetcode.cn/problems/find-if-path-exists-in-graph/description/)
##### 思想：先开一个地图，存每个节点的邻居，方便后续遍历，接下来进行递归遍历，从source开始，每遍历一个节点，就标记已访问，直到遍历的顶点为des时，表示source到des有路径

```c
class Solution {
public:
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {
        vector<vector<int>>adj(n);
        vector<bool>visited(n,false);
        for(auto& edge:edges){
            int x=edge[0];
            int y=edge[1];
            adj[x].push_back(y);
            adj[y].push_back(x);
        }
      return  dfs(adj,source,destination,visited);
    }
  bool dfs(vector<vector<int>>&adj,int source,int destination,vector<bool>&visited){
    visited[source]=true;
        if(source==destination)return true;
        for(int neighbor:adj[source]){
            if(!visited[neighbor]){//若邻居没有被访问，
               if(dfs(adj,neighbor,destination,visited)){//则递归遍历邻居，。。。邻居的邻居
                        return true;//如果邻居的位置等于des，表示可以到达
               }
               
               
            }
        }
        return false;
    }
};
```


## 拓扑排序
### BFS 
#### 思想：找出所有入度为0的顶点（入队），从该顶点出发，消除与之相连的边，如果存在入度为0 就纳入队列中 直到将所有顶点都入队 则表示存在拓扑排序
#### [207. 课程表](https://leetcode.cn/problems/course-schedule/description/)

```c
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        vector<vector<int>>adj(numCourses);//adj中保存邻居
        vector<int>indegree(numCourses,0);
        for(auto& prerequisite:prerequisites){
            int x=prerequisite[0];
            int y=prerequisite[1];
            adj[y].push_back(x);
            indegree[x]++;//表示x存在一条入边
        }
        queue<int>q;
        int count=0;
        for(int i=0;i<numCourses;i++){
            if(indegree[i]==0){//将入度为0的点入队
                q.push(i);
                count++;
            }
        }
        while(!empty(q)){
            int cur=q.front();
            q.pop();
            for(int neighbor:adj[cur]){//遍历其邻居 消除相连的边 若还存在入度为0 则加入队列中
                indegree[neighbor]--;
                if(indegree[neighbor]==0){
                    q.push(neighbor);
                    count++;
                }
            }
        }
        return numCourses==count;//若加入队列中的点的数量与课程数相等，表示所有课程都可完成

    }
};
```
