# 图
## 图的遍历
### BFS
#### [1971. 寻找图中是否存在路径](https://leetcode.cn/problems/find-if-path-exists-in-graph)
```c
class Solution {
public:
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {
        vector<vector<int>>adj(n);
        vector<bool>visited(n,false);
        queue<int>qu;
        for(auto& edge:edges){
            int x=edge[0];
            int y=edge[1];
            adj[x].push_back(y);//因为双向边 存0-1
            adj[y].push_back(x);//存 1-0
        }
        return  bfs(source,destination,adj,visited,qu);
    }
  bool  bfs(int source,int destination,vector<vector<int>>&adj,vector<bool>&visited,queue<int>&qu){
                if(source==destination)return true;  //判断边界情况 若只有一个顶点 即源点和终点一样
                visited[source]=true;//访问source
                qu.push(source);//将source入队
                while(!empty(qu)){
                    auto cur=qu.front();//取出队首元素
                    qu.pop();//移出
                    for(int neighbor:adj[cur]){//取出当前队首元素的所有邻居
                        
                        if(!visited[neighbor]){//如果该邻居没有被访问，则访问它 ，并将其入队 如果该邻居与des相等，则return true
                            visited[neighbor]=true;
                          if(neighbor==destination)return true;
                          qu.push(neighbor);  
                        }
                       
                    }
                }
                return false;//已经将source的邻居，以及邻居的邻居入队了，也并且都已访问。若终点不在被访问的队伍中，则表示从source出发 到达不了终点 表示source与destination不连通
        }
};
```
